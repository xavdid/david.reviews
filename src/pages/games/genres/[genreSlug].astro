---
import { GENRE_DESCRIPTIONS, type Game } from "../../../airtable/data/games";
import {
  loadPlays,
  type Play,
  type PlayTypes,
} from "../../../airtable/data/plays";
import PageTitle from "../../../components/PageTitle.astro";
import RoundedText from "../../../components/RoundedText.astro";
import RoundedLink from "../../../components/links/RoundedLink.astro";
import Layout from "../../../layouts/Layout.astro";
import { genrePermalink, ratingPage, seoTitle } from "../../../utils/data";
import SlimBox from "../../../components/infoboxes/SlimBox.astro";
import SubtleLink from "../../../components/links/SubtleLink.astro";

type Params = {
  genreSlug: string;
};

type GameAndPlays = {
  game: Game;
  plays: Play[];
};
type Props = {
  genre: { name: string; slug: string };
  games: GameAndPlays[];
};

// own row for weird export reasons
type Result = Promise<Array<{ params: Params; props: Props }>>;
export const getStaticPaths = async (): Result => {
  const plays = await loadPlays();

  const games = plays.reduce<Record<string, GameAndPlays>>((result, play) => {
    // for review/average, only note full plays
    if (
      (["First Time", "Replay", "New Edition"] as PlayTypes[]).includes(
        play.playType,
      )
    ) {
      const igdbId = play.game.igdbId;

      result[igdbId] ||= {
        game: play.game,
        plays: [],
      };

      result[igdbId].plays.push(play);
    }
    return result;
  }, {});

  const genres = Object.values(games).reduce<Record<string, Props>>(
    (result, gameWithPlays) => {
      const { name, slug } = gameWithPlays.game.genre;

      result[slug] ||= {
        genre: { name, slug },
        games: [],
      };

      result[slug].games.push(gameWithPlays);

      return result;
    },
    {},
  );

  return Object.entries(genres).map(([genreSlug, props]) => ({
    params: { genreSlug },
    props,
  }));
};

const { games, genre } = Astro.props;
const processedGames = games
  .map(({ game, plays }) => {
    // i'm going to show info about the most relevant play, which is probably the one I had the most to say about
    const bestPlay = plays.reduce((result, item) =>
      result.notes.length > item.notes.length ? result : item,
    );

    return {
      title: game.title,
      rating: bestPlay.rating,
      permalink: game.permalink,
      posterUrl: game.posterUrl,
      dateFinished: bestPlay.dateFinished,
      // the longest review is probably the best one?
      blurb: bestPlay.notes,
    };
  })
  // if someone is reading this page, we can assume they'd sort by score
  // in ties, it's most recent first, which should be fine
  .toSorted(
    (a, b) =>
      b.rating - a.rating ||
      new Date(b.dateFinished).valueOf() - new Date(a.dateFinished).valueOf(),
  );
---

<Layout
  pageTitle={`${genre.name} Games`}
  pageDescription={`Find your next favorite ${genre.name} in this list of ${processedGames.length} of them!`}
  seoTitle={seoTitle(`${genre.name} Games`)}
  activeTab="games"
>
  <div class="py-3">
    <PageTitle>
      <RoundedText text={genre.name} /> Games I've Played
    </PageTitle>
    <p class="pt-3">
      {genre.name} games are categorized by a primary gameplay loop of {
        GENRE_DESCRIPTIONS[genre.slug] ??
          (() => {
            throw new Error("MISSING GENRE DESCRIPTION!");
          })()
      } I've played {games.length} game{games.length > 1 ? "s" : ""} in this
      genre so far.
    </p>
    <p class="py-3">
      Each game is scored on my <SubtleLink href={ratingPage("games")}>
        {"4-point rating system"}
      </SubtleLink>.
    </p>
    <p class="pt-2">
      ⬅️ You can also go back to <RoundedLink href={genrePermalink("")}>
        {"all genres"}
      </RoundedLink>
    </p>
  </div>
  <div>
    {processedGames.map((game) => <SlimBox {...game} mediaType="games" />)}
  </div>
</Layout>
